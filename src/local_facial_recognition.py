"""
This file handles all the local facial recognition functionality.
"""

import time
import os
import sqlite3
from shutil import copyfile
from collections import namedtuple
from numpy import array_equal

import face_recognition

from src import conversions

CompareResult = namedtuple('CompareResult', ['matchCount', 'notMatchCount'])
__all__ = ['get_person_db_encodings', 'save_image', 'save_face_encoding', 'generate_face_encoding',
           'get_person_directory', 'compare_encoding_to_person', 'identify_person_from_encoding', 'CompareResult']


MAX_INT = 99999999


def get_person_db_encodings(name, debug=False):
    """
    Given a name retrieve all the facial encodings corresponding to that person

    :param name: Name of the person to retrieve facial encodings for
    :type name: str
    :param debug: Enable debug mode
    :type debug: bool
    :return: List of facial encodings corresponding to the person with name `name`
    :rtype: list(nd_array)
    """

    conn = sqlite3.connect('./hw2.db')
    cursor = conn.cursor()
    if conn:
        # Collect all encodings for the person
        normalized_name = conversions.get_normalized_name(name)
        query = f"SELECT ENCODING FROM NAME_ENCODING WHERE NAME = '{normalized_name}'"
        cursor.execute(query)
        conn.commit()

        # Convert the encodings from strings to ndarrays and return them
        rows = cursor.fetchall()
        encodings = [conversions.decode_memoryview_to_ndarray(row[0]) for row in rows]
        if debug:
            print(f'Found {len(encodings)} encodings for {name}')
        return encodings
    if debug:
        print("Failed to connect to database.")
    return []


def add_to_db(file_location, encoding, name, source='user'):
    """
    Save an image and pre-generated encoding into the DB without generating a new encoding

    :param file_location: Location of the file to save
    :type file_location: str
    :param encoding: Encoding of the person in the image
    :type encoding: ndarray(128,)
    :param name: Name of the person in the image
    :type name: str
    :param source: Source of the images. Default is 'user' (user provided)
                   but can also be databases such as 'lfw' (Labeled Faces in the Wild).
    :type source: str
    :return: True for successful save, False for error
    :rtype: bool
    """
    new_file_name, _ = generate_file_name_strenc(file_location, encoding)
    save_image(file_location, name, new_file_name)
    result = save_face_encoding(encoding, name, file_location, source)
    return result


def save_image(file_location, name, new_file_name):
    """
    Provided an image save it in the proper location given the person's name

    :param file_location: Path of a file (including file name)
    :type file_location: str
    :param name: Name of the person in the picture
    :type name: str
    :param new_file_name: Name of the file to save the image as
    :type new_file_name: str
    """

    normalized_name = conversions.get_normalized_name(name)
    output_directory = f'./images/{normalized_name}'
    conn = sqlite3.connect('./hw2.db')
    cursor = conn.cursor()
    if conn:
        # Check if the person exists in the database
        query = f"SELECT NAME FROM NAME_DIRECTORY WHERE NAME = '{normalized_name}'"
        cursor.execute(query)
        conn.commit()
        row = cursor.fetchone()
        if row is None:
            # Person is not in the database
            # If name not in NAME_DIRECTORY create a directory and add it to the table
            if not os.path.exists('./images'):
                os.mkdir('./images')
            if not os.path.exists(output_directory):
                # Create the directory if it doesn't exist -- It shouldn't!
                os.mkdir(output_directory)

            # Add initial reference to person
            conn.execute("INSERT INTO NAME_DIRECTORY (NAME, DIRECTORY, ENCODING_COUNT) VALUES (?, ?, ?)",
                         (normalized_name, output_directory, 0))
            conn.commit()
        conn.close()
    out_file = f'{output_directory}/{new_file_name}'
    copyfile(file_location, out_file)


def save_face_encoding(encoding, name, file_name, source='user'):
    """
    Provided a face encoding and the name of the person in the image, save the encoding to that corresponding person's
    encoding set

    :param encoding: Face encoding generated by face_recognition.face_encodings()
    :type encoding: memoryview
    :param name: Name of the person in the image
    :type name: str
    :param file_name: Name of the file the encoding was generated from (Example: George_W_Bush_0525.jpg)
    :type file_name: str
    :param source: Source of the images. Default is 'user' (user provided)
                   but can also be databases such as 'lfw' (Labeled Faces in the Wild).
    :type source: str
    :return: True for successful save, False for error
    :rtype: bool
    """

    normalized_name = conversions.get_normalized_name(name)
    conn = sqlite3.connect('./hw2.db')
    if conn:
        cursor = conn.cursor()
        encoding = encoding.tobytes()  # Convert memoryview to a byte string

        # Add the encoding to the database
        cursor.execute("INSERT INTO NAME_ENCODING (NAME, ENCODING, FILE_NAME, SOURCE) VALUES (?, ?, ?, ?)",
                       (normalized_name, encoding, file_name, source))
        conn.commit()

        # Increment the encoding count for the person
        cursor.execute("SELECT ENCODING_COUNT FROM NAME_DIRECTORY WHERE NAME=?", (normalized_name,))
        row = cursor.fetchone()
        if row is not None:
            encoding_count = row[0] + 1
            cursor.execute("UPDATE NAME_DIRECTORY SET ENCODING_COUNT=? WHERE NAME=?",
                           (encoding_count, normalized_name))
            conn.commit()
        conn.close()
        return True
    return False


def generate_file_name_strenc(file_location, encoding):
    """
    Given a file location and an encoding, generate a new file name and string encoding for the image

    :param file_location: Path of a file (including file name)
    :type file_location: str
    :param encoding: Encoding of the person in the image
    :type encoding: ndarray(128,)
    :return: New file name for the image
    :rtype: str
    """
    str_encoding = conversions.encode_ndarray_to_memoryview(encoding)
    hashed_encoding = str(hash(str_encoding))
    file_type = f'{file_location.split(".")[-1]}'  # Get the file type
    file_name = f'{hashed_encoding}.{file_type}'  # Generate a new file name
    return file_name, str_encoding


def generate_face_encoding(file_location, name='', source='user', debug=False):
    """
    Provided the path to an image, generate a facial encoding from that image.
    If a name is provided, save the encoding into the DB.

    :param file_location: Path of a file (including file name) to generate a facial encoding
    :type file_location: str
    :param name: Name of the person in the picture (optional)
    :type name: str or None
    :param source: Source of the images. Default is 'user' (user provided)
                   but can also be databases such as 'lfw' (Labeled Faces in the Wild).
    :type source: str
    :param debug: If True, print debug statements
    :type debug: bool
    :return: A list of 128-dimensional face encodings
    :rtype: list(float)
    """

    image = face_recognition.load_image_file(file_location)

    try:
        encoding = face_recognition.face_encodings(image)[0]
    except IndexError:
        return []

    if name != '':
        # If a name is provided, save the encoding into the DB
        file_name, str_encoding = generate_file_name_strenc(file_location, encoding)
        save_image(file_location, name, file_name)
        save_result = save_face_encoding(str_encoding, name, file_name, source)
        if debug:
            print(f'Encoding for "{name}" saved successfully: {save_result}')

    return encoding


def get_person_directory(name):
    """
    Given a name, retrieve the directory of that person

    :param name: Name of the person to retrieve the directory for
    :type name: str
    :return: Directory of the person
    :rtype: str or None
    """
    conn = sqlite3.connect('./hw2.db')
    cursor = conn.cursor()
    if conn:
        # Check if the person exists in the database
        query = f"SELECT DIRECTORY FROM NAME_DIRECTORY WHERE NAME = '{name}'"
        cursor.execute(query)
        conn.commit()
        row = cursor.fetchone()
        if row is not None:
            return row[0]
        conn.close()
    return None


def compare_encoding_to_person(encoding, name, compare_encodings):
    """
    Given an encoding and a person's name, compare the encoding to all encodings of that person

    :param encoding: Encoding to compare against all encodings of the person
    :type encoding: ndarray(128,)
    :param name: Name of the person to compare the encoding to
    :type name: str
    :param compare_encodings: All encodings of a given person to compare the encoding to
    :type compare_encodings: list(ndarray(128,))
    :return: CompareResult of the comparison
    :rtype: CompareResult
    """
    if len(compare_encodings) == 0:
        print(f'No encodings found for {name}')
        return None

    comparison_result = face_recognition.compare_faces(compare_encodings, encoding, tolerance=0.4)
    comparison_result = CompareResult(matchCount=comparison_result.count(True),
                                      notMatchCount=comparison_result.count(False))

    for cmp in compare_encodings:
        if array_equal(encoding, cmp):
            comparison_result = CompareResult(matchCount=MAX_INT,
                                              notMatchCount=0)
            return comparison_result

    return comparison_result


def identify_person_from_encoding(encoding, debug=False):
    """
    Given an encoding, compare it to all encodings in the database to find the person's name.

    :param encoding: Encoding to compare against all encodings in the database. Encoding of the person to identify.
    :type encoding: ndarray(128,)
    :param debug: Enables debug mode
    :type debug: bool
    :return: Name of the person with the most matches or UNKNOWN if no matches were found
    :rtype: str
    """
    start_time = time.time()

    conn = sqlite3.connect('./hw2.db')
    cursor = conn.cursor()
    if conn:
        # Get all encodings from the database
        query = "SELECT NAME, ENCODING FROM NAME_ENCODING"
        cursor.execute(query)
        conn.commit()
        rows = cursor.fetchall()
        conn.close()

        encodings = {}
        for row in rows:
            this_name = row[0]
            this_encoding = conversions.decode_memoryview_to_ndarray(row[1])
            if this_name in encodings:
                encodings[this_name].append(this_encoding)
            else:
                encodings[this_name] = [this_encoding]

        possible_people = {}
        for this_name, compare_encodings in encodings.items():
            comparison_result = compare_encoding_to_person(encoding, this_name, compare_encodings)
            match_rate = comparison_result.matchCount / (comparison_result.matchCount + comparison_result.notMatchCount)
            if match_rate >= 0.6 and comparison_result.matchCount > comparison_result.notMatchCount:
                # If the match rate is greater than 50% and there are more matches than not matches
                possible_people[this_name] = comparison_result

        max_match = 0
        max_match_name = ''
        for person, comparison_result in possible_people.items():
            if comparison_result.matchCount > max_match:
                max_match = comparison_result.matchCount
                max_match_name = person

        if max_match_name == '':
            max_match_name = 'UNKNOWN PERSON'

        if debug:
            if max_match_name == 'UNKNOWN PERSON':
                print('No matches found!')
            else:
                print(f'Max match: {conversions.get_normalized_name(max_match_name)} @ {max_match} matches!')
            compare_time = time.time() - start_time
            print(f'Compared {len(rows)} encodings in {compare_time} seconds.')

        return max_match_name
    return 'UNKNOWN PERSON'


if __name__ == '__main__':
    new_file_location = './test_images/Jacob_Weber/Jacob_Weber_dontsave.jpg'
    test_encoding = generate_face_encoding(new_file_location, debug=False)
    most_likely_person = identify_person_from_encoding(test_encoding, debug=False)
    print(f'Most likely person: {most_likely_person}')
