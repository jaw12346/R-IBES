import time
import os
import face_recognition
import sqlite3
from shutil import copyfile
from PIL import Image
from collections import namedtuple

import conversions

CompareResult = namedtuple('CompareResult', ['matchCount', 'notMatchCount'])


def get_sql_encodings(name):
    """
    Given a name retrieve all the facial encodings corresponding to that person

    :param name: Name of the person to retrieve facial encodings for
    :type name: str
    :return: List of facial encodings corresponding to the person with name `name`
    :rtype: list(nd_array)
    """

    conn = sqlite3.connect('./server/hw2.db')
    cursor = conn.cursor()
    if conn:
        # Collect all encodings for the person
        normalized_name = conversions.get_normalized_name(name)
        query = f"SELECT ENCODING FROM NAME_ENCODING WHERE NAME = '{normalized_name}'"
        cursor.execute(query)
        conn.commit()

        # Convert the encodings from strings to ndarrays and return them
        rows = cursor.fetchall()
        encodings = [conversions.decode_memoryview_to_ndarray(row[0]) for row in rows]
        print(f'Found {len(encodings)} encodings for {name}')
        return encodings
    print("Failed to connect to database.")
    return []


def save_image(file_location, name, new_file_name):
    """
    Provided an image save it in the proper location given the person's name

    :param file_location: Path of a file (including file name)
    :type file_location: str
    :param name: Name of the person in the picture
    :type name: str
    :param new_file_name: Name of the file to save the image as
    :type new_file_name: str
    :return: None
    """

    normalized_name = conversions.get_normalized_name(name)
    output_directory = f'./images/{normalized_name}'
    conn = sqlite3.connect('./server/hw2.db')
    cursor = conn.cursor()
    if conn:
        # Check if the person exists in the database
        query = f"SELECT NAME FROM NAME_DIRECTORY WHERE NAME = '{normalized_name}'"
        cursor.execute(query)
        conn.commit()
        row = cursor.fetchone()
        if row is None:
            # Person is not in the database
            # If name not in NAME_DIRECTORY create a directory and add it to the table
            if not os.path.exists('./images'):
                os.mkdir('./images')
            if not os.path.exists(output_directory):
                # Create the directory if it doesn't exist -- It shouldn't!
                os.mkdir(output_directory)

            # Add initial reference to person
            conn.execute("INSERT INTO NAME_DIRECTORY (NAME, DIRECTORY, ENCODING_COUNT) VALUES (?, ?, ?)",
                         (normalized_name, output_directory, 0))
            conn.commit()
        conn.close()

    out_file = f'{output_directory}/{new_file_name}'
    copyfile(file_location, out_file)


def save_face_encoding(encoding, name, file_name, source='user'):
    """
    Provided a face encoding and the name of the person in the image, save the encoding to that corresponding person's
    encoding set

    :param encoding: Face encoding generated by face_recognition.face_encodings()
    :type encoding: memoryview
    :param name: Name of the person in the image
    :type name: str
    :param file_name: Name of the file the encoding was generated from (Example: George_W_Bush_0525.jpg)
    :type file_name: str
    :param source: Source of the images. Default is 'user' (user provided)
                   but can also be databases such as 'lfw' (Labeled Faces in the Wild).
    :type source: str
    :return: True for successful save, False for error
    :rtype: bool
    """

    normalized_name = conversions.get_normalized_name(name)
    conn = sqlite3.connect('./server/hw2.db')
    if conn:
        cursor = conn.cursor()
        encoding = encoding.tobytes()  # Convert memoryview to a byte string

        # Add the encoding to the database
        cursor.execute("INSERT INTO NAME_ENCODING (NAME, ENCODING, FILE_NAME, SOURCE) VALUES (?, ?, ?, ?)",
                       (normalized_name, encoding, file_name, source))
        conn.commit()

        # Increment the encoding count for the person
        cursor.execute("SELECT ENCODING_COUNT FROM NAME_DIRECTORY WHERE NAME=?", (normalized_name,))
        row = cursor.fetchone()
        if row is not None:
            encoding_count = row[0] + 1
            cursor.execute("UPDATE NAME_DIRECTORY SET ENCODING_COUNT=? WHERE NAME=?",
                           (encoding_count, normalized_name))
            conn.commit()

        conn.close()
        return True
    return False


def generate_face_encoding(file_location, name='', source='user', debug=False):
    """
    Provided the path to an image, generate a facial encoding from that image.

    :param file_location: Path of a file (including file name) to generate a facial encoding
    :type file_location: str
    :param name: Name of the person in the picture (optional)
    :type name: str or None
    :param source: Source of the images. Default is 'user' (user provided)
                   but can also be databases such as 'lfw' (Labeled Faces in the Wild).
    :type source: str
    :param debug: If True, print debug statements
    :type debug: bool
    :return: A list of 128-dimensional face encodings
    :rtype: list(float)
    """

    image = face_recognition.load_image_file(file_location)

    try:
        encoding = face_recognition.face_encodings(image)[0]
    except IndexError:
        return []

    if name != '':
        str_encoding = conversions.encode_ndarray_to_memoryview(encoding)
        hashed_encoding = str(hash(str_encoding))
        file_type = f'{file_location.split(".")[-1]}'  # Get the file type
        file_name = f'{hashed_encoding}.{file_type}'  # Generate a new file name
        save_image(file_location, name, file_name)
        save_result = save_face_encoding(str_encoding, name, file_name, source)
        if debug:
            print(f'Encoding for "{name}" saved successfully: {save_result}')

    return encoding


def get_person_directory(name):
    """
    Given a name, retrieve the directory of that person

    :param name: Name of the person to retrieve the directory for
    :type name: str
    :return: Directory of the person
    :rtype: str or None
    """
    conn = sqlite3.connect('./server/hw2.db')
    cursor = conn.cursor()
    if conn:
        # Check if the person exists in the database
        query = f"SELECT DIRECTORY FROM NAME_DIRECTORY WHERE NAME = '{name}'"
        cursor.execute(query)
        conn.commit()
        row = cursor.fetchone()
        if row is not None:
            return row[0]
        conn.close()
    return None


def compare_encoding_to_person(encoding, name, compare_encodings, debug=False):
    """
    Given an encoding and a person's name, compare the encoding to all encodings of that person

    :param encoding: Encoding to compare against all encodings of the person
    :type encoding: ndarray(128,)
    :param name: Name of the person to compare the encoding to
    :type name: str
    :param compare_encodings: All encodings of a given person to compare the encoding to
    :type compare_encodings: list(ndarray(128,))
    :param debug: Enables benchmarking of the comparison
    :type debug: bool
    :return: CompareResult of the comparison
    :rtype: CompareResult
    """
    if len(compare_encodings) == 0:
        print(f'No encodings found for {name}')
        return None

    start_time = time.time()
    if debug:
        print(f'Comparing {name} to {len(compare_encodings)} encodings.')
    comparison_result = face_recognition.compare_faces(compare_encodings, encoding)
    comparison_result = CompareResult(matchCount=comparison_result.count(True),
                                      notMatchCount=comparison_result.count(False))
    if debug:
        compare_time = time.time() - start_time
        print(f'{name}: Compared {len(compare_encodings)} '
              f'encodings in {compare_time} seconds.')
        print(f'\tMatch: {comparison_result.matchCount}\n\tNot Match: {comparison_result.notMatchCount}')

    return comparison_result


def compare_encoding_to_all(encoding, debug=False):
    """
    Given an encoding, compare it to all encodings in the database to find the person's name.

    :param encoding: Encoding to compare against all encodings in the database. Encoding of the person to identify.
    :type encoding: ndarray(128,)
    :param debug: Enables debug mode
    :type debug: bool
    :return:
    """
    start_time = time.time()

    conn = sqlite3.connect('./server/hw2.db')
    cursor = conn.cursor()
    if conn:
        # Get all encodings from the database
        query = "SELECT NAME, ENCODING FROM NAME_ENCODING"
        cursor.execute(query)
        conn.commit()
        rows = cursor.fetchall()
        conn.close()

        encodings = {}
        for row in rows:
            this_name = row[0]
            this_encoding = conversions.decode_memoryview_to_ndarray(row[1])
            if this_name in encodings:
                encodings[this_name].append(this_encoding)
            else:
                encodings[this_name] = [this_encoding]

        possible_people = {}
        for this_name in encodings:
            compare_encodings = encodings[this_name]
            comparison_result = compare_encoding_to_person(encoding, this_name, compare_encodings, debug)
            if comparison_result.matchCount > comparison_result.notMatchCount:
                possible_people[this_name] = comparison_result

        max_match = 0
        max_match_name = ''
        for person in possible_people:
            comparison_result = possible_people[person]
            if comparison_result.matchCount > max_match:
                max_match = comparison_result.matchCount
                max_match_name = person

        if debug:
            print(f'Max match: {conversions.get_normalized_name(max_match_name)} @ {max_match} matches!')
            compare_time = time.time() - start_time
            print(f'Compared {len(rows)} encodings in {compare_time} seconds.')
        return max_match_name


def align_face(df_face, file_location, debug=False):
    """
    Given a dataframe containing the coordinates of a face, crop the image to the face and display it
    :param df_face: Dataframe containing the coordinates of the face
    :type df_face: dict
    :param file_location: Location of the file to crop
    :type file_location: str
    :param debug: If True, show the image for 5 seconds
    :type debug: bool
    :return: Location of the cropped image
    :rtype: str
    """
    img = Image.open(file_location)
    img = img.convert('L')  # Convert img to greyscale

    # Get the coordinates of the face
    x = df_face['facial_area']['x']
    y = df_face['facial_area']['y']
    w = df_face['facial_area']['w']
    h = df_face['facial_area']['h']

    cropped = img.crop((x, y, x + w, y + h))  # Crop the image to the face
    if debug:
        cropped.show()  # Display the cropped image
        time.sleep(5)  # Show the image for 5 seconds

    # Save the cropped image
    old_name = file_location.split('/')[-1]
    new_name = f'cropped-{old_name}'
    new_location = file_location.split(old_name)[0] + new_name
    cropped.save(new_location)
    return new_location  # Return the location of the cropped image


if __name__ == '__main__':
    test_name = 'Jacob Weber'
    new_file_location = './test_images/Jacob_Weber/Jacob_Weber_0003.png'
    test_encoding = generate_face_encoding(new_file_location, test_name, debug=False)
    most_likely_person = compare_encoding_to_all(test_encoding, debug=True)
